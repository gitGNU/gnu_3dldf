@q main.web @>
                           
@q * Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>
 
@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Main.@>
@** Main\quad ({\tt main\PERIOD web}).\hfil

@q * (1) Include files.@>
@ Include files.

@<Include files@>=

#if HAVE_CONFIG_H
#include "config.h"
#endif 

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>   
#include <string.h>
#include <getopt.h> 
#include <stdarg.h>
#include <errno.h>
#include <math.h>
#include <float.h>  
#include <limits.h>

#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <iterator>
#include <sstream>   
#include <string> 
#include <limits>     
#include <valarray>     
#include <vector>     

#include <pthread.h>   

#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "utility.h++"
#include "cmdlnopt.h++"
#include "transfor.h++"
#include "shapes.h++"
#include "points.h++"
#include "paths.h++"
#include "solids.h++"

typedef void* yyscan_t;

#include "parser.h++"


@q * (1) main function.  @>
@ |main| function.  
\initials{LDF 2014.06.12.}

@<|main| definition@>=
int
main(int argc, char *argv[])
{
@q ** (2) @>

   bool DEBUG = true;  /* |false| */

   int status = 0;

   set_debug_level(DEBUG);

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "Entering `main'." << endl;

#if 0 
#ifdef WORDS_BIGENDIAN
       cerr << "WORDS_BIGENDIAN == " << WORDS_BIGENDIAN << endl;
#else
       cerr << "WORDS_BIGENDIAN is not defined." << endl;
#endif 
#endif 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ** (2) Initializations.  @>
@ Initializations.
\initials{LDF 2014.06.13.}

\LOG
\initials{LDF 2014.06.13.}
Added this section.
\ENDLOG

@q *** (3) Register functions with |atexit|.  @>

@ Register functions with |atexit|.  Currently, only |finish|
is registered.
\initials{LDF 2014.06.13.}

@<|main| definition@>=

@q **** (4) @>

   errno = 0;
   status = atexit(finish);

   if (status == -1)
   {
       cerr << "[Thread 0] ERROR!  In `main':  `atexit' failed, "
            << "returning -1:"
            << endl
            << strerror(errno)
            << endl
            << "Failed to register `finish' using `atexit'."
            << endl
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status == -1)|  */

@q **** (4) @>  

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `main':  `atexit' succeeded."
            << endl 
            << "Registered `finish' using `atexit' successfully."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q **** (4) @>

@q *** (3) Initialize mutexes.  @>

@ Initialize mutexes.
\initials{LDF 2014.06.13.}

@q **** (4) |cout_mutex|. @>

@ |cout_mutex|.
\initials{LDF 2014.06.13.}

@<|main| definition@>=

   status = pthread_mutex_init(&cout_mutex, 0);

   if (status != 0)
   {
       cerr << "[Thread 0] ERROR!  In `main':  `pthread_mutex_init' "
            << "failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to initialize `cout_mutex'."
            << endl 
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `main':  `pthread_mutex_init' "
            << "succeeded, returning 0."
            << endl
            << "Initialized `cout_mutex' successfully."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q **** (4) |cerr_mutex|. @>

@ |cerr_mutex|.
\initials{LDF 2014.06.13.}

@<|main| definition@>=

   status = pthread_mutex_init(&cerr_mutex, 0);

   if (status != 0)
   {
       cerr << "[Thread 0] ERROR!  In `main':  `pthread_mutex_init' "
            << "failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to initialize `cerr_mutex'."
            << endl 
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `main':  `pthread_mutex_init' "
            << "succeeded, returning 0."
            << endl
            << "Initialized `cerr_mutex' successfully."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ** (2) Process command-line options.  @>

@ Process command-line options.  
\initials{LDF 2014.06.13.}

\LOG
\initials{LDF 2014.06.13.}
Added this section.
\ENDLOG

@<|main| definition@>=

@q *** (3) @>

   status = process_command_line_options(argc, argv);

   if (status != 0)
   {
       cerr << "[Thread 0] ERROR!  In `main':  `process_command_line_options' "
            << "failed, returning " << status << ":"
            << endl
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status != 0)|  */

@q *** (3) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `main':  `process_command_line_options' "
            << "succeeded, returning 0."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q *** (3) @>

@q ** (2) @>
@
@<|main| definition@>=

/* !! START HERE:  Testing.  LDF 2014.06.12. */
#if 0 
   Transform<float>     t0;
   Transform<double, 1> t1; 

#if DEBUG_COMPILE
   if (DEBUG)
   {

       t0.show("t0:");

       t1.show("t1:");


   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
#endif 


@q ** (2) @>
@
@<|main| definition@>=


#if 0 
   Point<float> p0;

   p0.show("p0:");

   Path<float> q0;

   q0.show("q0:");



   Solid<float> s0;

   s0.show("s0");

#endif 

   Point<float, 0> p0;

   p0.show("p0:");

fprintf(stderr, "Type <RETURN> to continue");
getchar(); 

   p0.init_transform();

   p0.show("p0:");

fprintf(stderr, "Type <RETURN> to continue");
getchar(); 

   Point<float, 0> p1(true);

   p1.show("p1:");

fprintf(stderr, "Type <RETURN> to continue");
getchar(); 


   Path<float> q0;

   q0.show("q0:");

fprintf(stderr, "Type <RETURN> to continue");
getchar(); 


   Solid<float> s0;

   s0.show("s0");

fprintf(stderr, "Type <RETURN> to continue");
getchar(); 


@q ** (2) Read input.  @>
@
@<|main| definition@>=

#if 0 

   yyscan_t parameter;

#if 0 

/* !! START HERE:    LDF 2014.06.15.  This requires a more recent flex.  */

   yylex_init(&parameter);

   int param;


   yyset_extra(&param, parameter);

   YY_BUFFER_STATE yy_buffer_state;

#endif 

#if DEBUG_COMPILE
   if (DEBUG)
   {
      cerr << "[Thread 0] In `main':  `input_filenames.size()' == " 
           << input_filenames.size()
           << endl;


      if (input_filenames.size() > 0)
      {
          cerr << "`input_filenames':" << endl;
        
          int i = 1;

          for (vector<string>::iterator iter = input_filenames.begin();
               iter != input_filenames.end();
               ++iter)
          {
              cerr << setw(2) << i++ << ".  " << *iter << endl;
          }
      }

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */    

   int param = 0;

   FILE *fp = 0;

   fp = fopen("test_input.txt", "r");

   yyin = fp;

   status = yyparse();

   if (status != 0)
   {
      cerr << "[Thread 0] ERROR!  In `main':  `yyparse' failed, returning "
           << status 
           << endl
           << "Exiting 3dldf unsuccessfully with exit status 1."
           << endl;

      fclose(fp);
      fp = 0;

      exit(1);

   }  /* |if (status != 0)|  */

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] `yyparse' succeeded, returning 0."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   fclose(fp);
   fp = 0;

#endif 


@q ** (2) @>
@
@<|main| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       cerr << "Exiting `main' successfully with exit status 0." 
            << endl;

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   exit(0);


}  /* End of |main| definition  */


@q * (1) Finish (|finish|).  @>

@ Finish (|finish|).  
\initials{LDF 2014.06.13.}

This function is registered using |atexit|.
\initials{LDF 2014.06.13.}

@q ** (2) Declaration @>

@<|finish| declaration@>=
void
finish(void);

@q ** (2) Definition  @>
@
@<|finish| definition@>=
void
finish(void)
{
   int status = 0;

   bool DEBUG = true; /* |false|  */

   set_debug_level(DEBUG);

@q *** (3) Destroy mutexes.  @>

@ Destroy mutexes.
\initials{LDF 2014.06.13.}

@q **** (4) |cerr_mutex|. @>

@ |cerr_mutex|.
\initials{LDF 2014.06.13.}

@<|finish| definition@>=

@q ***** (5) @>

   status = pthread_mutex_destroy(&cout_mutex);

   if (status != 0)
   {
       cerr << "[Thread 0] ERROR!  In `finish':  `pthread_mutex_destroy' "
            << "failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to destroy `cout_mutex'."
            << endl 
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `finish':  `pthread_mutex_destroy' "
            << "succeeded, returning 0."
            << endl
            << "Destroyed `cout_mutex' successfully."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>

@q **** (4) |cerr_mutex|. @>

@ |cerr_mutex|.
\initials{LDF 2014.06.13.}

@<|finish| definition@>=

@q ***** (5) @>

   status = pthread_mutex_destroy(&cerr_mutex);

   if (status != 0)
   {
       cerr << "[Thread 0] ERROR!  In `finish':  `pthread_mutex_destroy' "
            << "failed, returning " << status << ":"
            << endl
            << strerror(status)
            << endl
            << "Failed to destroy `cerr_mutex'."
            << endl 
            << "Exiting `3dldf' unsuccessfully with exit status 1."
            << endl;

       exit(1);

   }  /* |if (status != 0)|  */

@q ***** (5) @>

#if DEBUG_COMPILE
   else if (DEBUG)
   {
       cerr << "[Thread 0] In `finish':  `pthread_mutex_destroy' "
            << "succeeded, returning 0."
            << endl
            << "Destroyed `cerr_mutex' successfully."
            << endl;

   }  /* |else if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 
   return;  

@q ***** (5) @>

@q **** (4) @>

@q *** (3) @>

   return;

}  /* End of |finish| definition  */


@q * (1) Putting |main| together.  @>
@ Putting |main| together.  
\initials{LDF 2014.06.12.}

@q ** (2) @>

@ This is what's compiled.
\initials{LDF 2014.06.12.}

@c

@<Include files@>@;@/
using namespace std;
using namespace tdldf;


extern FILE *yyin;

int
yylex(void);

int
yywrap(void);

int
yyerror(void *v, char const *s);

@<|finish| declaration@>@;@/
@<|main| definition@>@;@/
@<|finish| definition@>@;@/

@q ** (2) @>

@ This is what's written to the (empty) header file.
\initials{LDF 2014.06.12.}

@(main.h@>=
#ifndef LDF_MAIN_H_KNOWN
#define LDF_MAIN_H_KNOWN
#endif

@q * Emacs-Lisp code for use in indirect buffers  @>

@q   (progn (cweb-mode) (outline-minor-mode t))   @>

  
@q * Local variables for Emacs.@>
@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q fill-column:80 @>
@q End: @>

