@q points.web @>
          
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q ("@@" stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with "subscribe <email-address>" as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single "at" sign.)@>


@q * (0) class Point.@>
@** {\bf class Point}\quad ({\tt points\PERIOD web}).\hfil

@q * Include files. @>

@ Include files.
\initials{LDF 2014.06.14.}

@<Include files@>=

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>   
#include <string.h>
#include <errno.h>
#include <math.h>
#include <float.h>  
#include <limits.h>

#include <string> 
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <sstream>   

#include <valarray>   
#include <vector>   

#include <limits>     

#include <pthread.h>   

#if HAVE_CONFIG_H
#include "config.h"
#endif 

#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "utility.h++"
#include "transfor.h++"
#include "shapes.h++"

@q * (1) |class Point|.  @>

@ |class Point|.
\initials{LDF 2014.06.14.}

@<Declare |class Point|@>=

template <class C, unsigned int T = 0> 
class Point : public Shape<C, T>
{

   int type;
   string type_name; 

   valarray<C> world_coordinates;
   valarray<C> projective_coordinates;

   public:

   @<Declare |Point| functions@>@;@/

};

@q ** (2) |Point| function definitions.  @>
@ |Point| function definitions.  
\initials{LDF 2014.06.15.}

\LOG
\initials{LDF 2014.06.15.}
Added this section.
\ENDLOG

@q *** (3) Constructors.  @>

@ Constructors.  
\initials{LDF 2014.06.15.}

\LOG
\initials{LDF 2014.06.15.}
Added this section.
\ENDLOG

@q **** (4) Default constructor.  @>
@ Default constructor.
\initials{LDF 2014.06.15.}

\LOG
\initials{LDF 2014.06.15.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<Declare |Point| functions@>=

Point(void);

@q ***** (5) Definition  @>
@
@<|Point| constructor definitions@>=

template <class C, unsigned int T>
Point<C,T>::Point(void)
{
@q ****** (6) @>

    bool DEBUG = false;  /* |true|  */
    set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Point' default constructor."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>
@
@<|Point| constructor definitions@>=

   type = T;

   if (type == 0)
      type_name = "float";
   else if (type == 1)
      type_name = "double";
   else if (type == 2)
      type_name = "long double";
  else if (type == 3)
     type_name = "complex";
   else 
      type_name = "unknown type";

@q ****** (6) @>
@
@<|Point| constructor definitions@>=

   Shape<C, T>::transform = 0;

   world_coordinates.resize(4, static_cast<C>(0));
   projective_coordinates.resize(4, static_cast<C>(0));

@q ****** (6) @>
@
@<|Point| constructor definitions@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Point' default constructor successfully "
            << "with `void' return value."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

}  /* |End| of |Point| default constructor definition  */

@q ***** (5) @>

@q **** (4) @>


@q **** (4) Destructor.  @>
@ Destructor.
\initials{LDF 2014.06.24.}

\LOG
\initials{LDF 2014.06.24.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<Declare |Point| functions@>=

~Point(void);

@q ***** (5) Definition  @>
@
@<|Point| destructor definition@>=

template <class C, unsigned int T>
Point<C,T>::~Point(void)
{

   if (static_cast<Transform<C, T>*>(Shape<C, T>::transform) != 0)
   {
      delete static_cast<Transform<C, T>*>(Shape<C, T>::transform);
      Shape<C, T>::transform = 0;
   }

   return;

}  /* End of |Point| destructor definition  */

@q *** (3) Initialize |transform| (|init_transform|).  @>
@ Initialize |transform| (|init_transform|).
\initials{LDF 2014.06.24.}

\LOG
\initials{LDF 2014.06.24.}
Added this function.
\ENDLOG

@q **** (4) Declaration @>

@<Declare |Point| functions@>=

int
init_transform(void);

@q **** (4) Definition  @>
@
@<|Point::init_transform| definition@>=
template <class C, unsigned int T>
int
Point<C,T>::init_transform(void)
{
@q ***** (5) @>

   bool DEBUG = true;  /* |false|  */
   set_debug_level(DEBUG, 0, 0); 

   try
   {
      Shape<C, T>::transform = new Transform<C, T>;
   }
   catch (...)
   {

      lock_cerr_mutex(); 
      cerr << "ERROR!  In `init_transform':"
           << endl 
           << "`new' failed, throwing an exception."
           << endl
           << "Failed to allocate new `Transform'." 
           << endl
           << "Exiting `Transform::init_transform' unsuccessfully "
           << "with return value 1."
           << endl;
      unlock_cerr_mutex(); 

      return 1;

   }

@q ***** (5) @>

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "In `init_transform':"
            << endl 
            << "`new' succeeded."
            << endl
            << "Allocated new `Transform' successfully." 
            << endl
            << "Exiting function successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

   return 0;

@q ***** (5) @>

}  /* End of |init_transform| definition  */

@q *** (3) Show (|show|).  @>
@ Show (|show|).
\initials{LDF 2014.06.15.}

\LOG
\initials{LDF 2014.06.15.}
Added this function.
\ENDLOG

@q **** (4) Declaration  @>

@<Declare |Point| functions@>=

int
show(string s = "Point:");

@q **** (4) Definition  @>
@
@<|Point::show| definition@>=

template <class C, unsigned int T>
int
Point<C, T>::show(string s)
{
@q ***** (5) @>

    bool DEBUG = true;  /* |false|  */
    set_debug_level(DEBUG, 0, 0); 

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Entering `Point::show'."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ***** (5) @>
@
@<|Point::show| definition@>=

   cerr << s << endl
        << "type:       " << type
        << endl 
        << "type_name:  " << type_name
        << endl
        << "world_coordinates:"
        << endl
        << "(";

   for (int i = 0; i < 4; ++i)
   {
       cerr << world_coordinates[i];

       if (i < 3)
          cerr << ", ";

   }  /* |for|  */
      
   cerr << ")" << endl;

   cerr << "projective_coordinates:"
        << endl
        << "(";

   for (int i = 0; i < 4; ++i)
   {
       cerr << projective_coordinates[i];

       if (i < 3)
          cerr << ", ";

   }  /* |for|  */
      
   cerr << ")" << endl;

@q ***** (5) @>
@
@<|Point::show| definition@>=

   if (Shape<C, T>::transform == static_cast<Transform<C, T>*>(0))
      cerr << "transform:  NULL" << endl;
   else 
   {
      Shape<C, T>::transform->show("transform:");
   }

@q ***** (5) @>
@
@<|Point::show| definition@>=

#if DEBUG_COMPILE
   if (DEBUG)
   {
       lock_cerr_mutex(); 
       cerr << "Exiting `Point::show' successfully with return value 0."
            << endl;
       unlock_cerr_mutex(); 

   }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */ 

@q ****** (6) @>

}  /* |End| of |Point::show| definition  */




@q * (1) Putting Point together.@>
@* Putting {\bf Point}  together.

@q ** (2) This is what's compiled.@>
@ This is what's compiled.
\initials{LDF 2014.06.14.}

@c
@<Include files@>@;
@<Declare |class Point|@>@;
@<|Point| constructor definitions@>@;@/
@<|Point| destructor definition@>@;@/
@<|Point::init_transform| definition@>@;@/
@<|Point::show| definition@>@;@/

@q **  This is what's written to \filename{points.h}. @>
@ This is what's written to \filename{points.h}. 
\initials{LDF 2014.06.14.}

@(points.h@>=

@<Declare |class Point|@>@;
@<|Point| constructor definitions@>@;@/
@<|Point| destructor definition@>@;@/
@<|Point::init_transform| definition@>@;@/
@<|Point::show| definition@>@;@/
 

@q * Emacs-Lisp code for use in indirect buffers                      @>

@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80)) @>


@q Local Variables: @>
@q mode:CWEB @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>

  
