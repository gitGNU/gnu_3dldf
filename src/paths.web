@q paths.web @>
   
@q * (0) Copyright and License.@>

@q This file is part of GNU 3DLDF, a package for three-dimensional drawing. @>
@q Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, @>
@q 2011, 2012, 2013, 2014 The Free Software Foundation @>

@q GNU 3DLDF is free software; you can redistribute it and/or modify @>
@q it under the terms of the GNU General Public License as published by @>
@q the Free Software Foundation; either version 3 of the License, or @>
@q (at your option) any later version. @>

@q GNU 3DLDF is distributed in the hope that it will be useful, @>
@q but WITHOUT ANY WARRANTY; without even the implied warranty of @>
@q MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the @>
@q GNU General Public License for more details. @>

@q You should have received a copy of the GNU General Public License @>
@q along with GNU 3DLDF; if not, write to the Free Software @>
@q Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA @>

@q GNU 3DLDF is a GNU package.  @>
@q It is part of the GNU Project of the  @>
@q Free Software Foundation @>
@q and is published under the GNU General Public License. @>
@q See the website http://www.gnu.org @>
@q for more information.   @>
@q GNU 3DLDF is available for downloading from @>
@q http://www.gnu.org/software/3dldf/LDF.html. @>

@q (``@@'' stands for a single at-sign in the following paragraph.) @>

@q Please send bug reports to Laurence.Finston@@gmx.de @>
@q The mailing list help-3dldf@@gnu.org is available for people to @>
@q ask other users for help.  @>
@q The mailing list info-3dldf@@gnu.org is for sending @>
@q announcements to users. To subscribe to these mailing lists, send an @>
@q email with ``subscribe <email-address>'' as the subject.  @>

@q The author can be contacted at: @>

@q Laurence D. Finston                 @> 
@q c/o Free Software Foundation, Inc.  @>
@q 51 Franklin St, Fifth Floor         @> 
@q Boston, MA  02110-1301              @>
@q USA                                 @>

@q Laurence.Finston@@gmx.de (@@ stands for a single ``at'' sign.)@>


@q * (0) Path.@>       
@** Path\quad ({\tt paths\PERIOD web}).\hfil
\initials{LDF Undated.}

@f Path Shape

@q * Include files. @>
@ Include files.

@<Include files@>=

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>   
#include <string.h>
#include <errno.h>
#include <math.h>
#include <float.h>  
#include <limits.h>

#include <string> 
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <sstream>   

#include <iterator>
#include <valarray>   
#include <vector>   

#include <limits>     

#include <pthread.h>   

#if HAVE_CONFIG_H
#include "config.h"
#endif 

#include "glblcnst.h++"
#include "glblvrbl.h++"
#include "utility.h++"
#include "transfor.h++"
#include "shapes.h++"
#include "points.h++"

@q * (1) class Path definition.@>
@* {\bf Path} class definition.

@<Declare |class Path|@>=

template <class C, unsigned int T = 0> 
class Path : public Shape<C, T>
{
    vector<Point<C, T> > point_vector;

    Point<C, T> center;
    Point<C, T> focus[2];
    C radius;
    C side_length;
    unsigned int side_ctr;

    public:

  @<Declare |Path| functions@>@;
};

@q ** (2) Path constructors.  @>

@q *** (3) Default constructor.  @>

@ Default constructor.  

@q **** (4) Declaration @>

@<Declare |Path| functions@>=

Path(bool allocate_transform = true);

@q **** (4) Definition  @>
@
@<|Path| constructor definitions@>=

template <class C, unsigned int T>
Path<C,T>::Path(bool allocate_transform)
{
@q ***** (5) @>

   bool DEBUG = true;  /* |false|  */
   set_debug_level(DEBUG, 0, 0); 

   int status = 0;

   radius      = static_cast<C>(0);
   side_length = static_cast<C>(0);;
   side_ctr    = 0U;

@q ***** (5) @>

   if (allocate_transform)
   {
@q ****** (6) @>

#if DEBUG_COMPILE
       if (DEBUG)
       {
           lock_cerr_mutex(); 
           cerr << "In `Path' default constructor:"
                << endl
                << "`allocate_transform' == `true'."
                << endl 
                << "Calling `Shape::init_transform'."
                << endl;
           unlock_cerr_mutex(); 

       }  /* |if (DEBUG)|  */
#endif  /* |DEBUG_COMPILE|  */     

@q ****** (6) @>

       status = Shape<C, T>::init_transform();

       if (status != 0)
       {
          lock_cerr_mutex(); 
          cerr << "ERROR!  In `Path' default constructor:"
               << endl
               << "`Shape::init_transform' failed, returning " 
               << status << ":"
               << endl
               << "Failed to initialize `Shape::transform'."
               << endl
               << "Throwing `bad_alloc' exception."
               << endl;

          unlock_cerr_mutex(); 

          throw bad_alloc();

@q ****** (6) @>

       }

@q ***** (5) @>

#if DEBUG_COMPILE
       else if (DEBUG)
       {
          lock_cerr_mutex(); 
          cerr << "In `Path' default constructor:"
               << endl
               << "`Shape::init_transform' succeeded, returning 0."
               << endl
               << "Initialized `Shape::transform' successfully."
               << endl;

          unlock_cerr_mutex(); 

       }  /* |else if (DEBUG)|  */

#endif  /* |DEBUG_COMPILE|  */ 

   }  /* |if (allocate_transform)|  */


@q ***** (5) @>


   return;

}  /* End of default |Path| constructor  */

@q **** (4) Destructor.  @>
@ Destructor.
\initials{LDF 2014.06.24.}

\LOG
\initials{LDF 2014.06.24.}
Added this function.
\ENDLOG

@q ***** (5) Declaration  @>

@<Declare |Path| functions@>=

~Path(void);

@q ***** (5) Definition  @>
@
@<|Path| destructor definition@>=

template <class C, unsigned int T>
Path<C,T>::~Path(void)
{

   return;

}  /* End of |Path| destructor definition  */

@q ** (2) Show (|show|).  @>
@ Show (|show|).

\LOG
\initials{LDF 2014.06.24.}
Added this function.
\ENDLOG

@q *** (3) Declaration @>

@<Declare |Path| functions@>=

void
show(string s = "Path:");

@q *** (3) Definition  @>
@
@<|Path::show| definition@>=

template <class C, unsigned int T>
void
Path<C,T>::show(string s)
{

   bool DEBUG = false;  /* |true|  */
   set_debug_level(DEBUG, 0, 0); 

   lock_cerr_mutex(); 

   cerr << s << endl;

   if (Shape<C, T>::transform == static_cast<Transform<C, T>*>(0))
      cerr << "transform:  NULL" << endl;
   else 
   {
      Shape<C, T>::transform->show("transform:");
   }

   center.show("center:");

   focus[0].show("focus[0]:");

   focus[1].show("focus[1]:");

   cerr << "radius:       " << radius
        << endl  
        << "side_length:  " << side_length
        << endl  
        << "side_ctr:     " << side_ctr
        << endl 
        << "point_vector.size():  " << point_vector.size()
        << endl;

   if (point_vector.size() > 0)
   {
      cerr << "point_vector:"
           << endl;
   }

   for (typename vector<Point<C, T> >::iterator iter = point_vector.begin();
        iter != point_vector.end();
        ++iter)
   {
       iter->show();
   }

   unlock_cerr_mutex(); 

   return;


}  /* End of |Path::show| definition  */



@q * (1) Putting Path together.@>
@ Putting {\bf Path} together.
\initials{LDF Undated.}

@q ** (2).@> 

@ This is what's compiled.

@c
@<Include files@>@;
@<Declare |class Path|@>@;
@<|Path| constructor definitions@>@;@/
@<|Path| destructor definition@>@;@/
@<|Path::show| definition@>@;@/

@q ** (2).@> 

@ This is what's written to \filename{paths.h}. 
\initials{LDF Undated.}

@(paths.h@>=
@<Declare |class Path|@>@;
@<|Path| constructor definitions@>@;@/
@<|Path| destructor definition@>@;@/
@<|Path::show| definition@>@;@/



@q * Emacs-Lisp code for use in indirect buffers.                        @>

@q   (progn (cweb-mode) (outline-minor-mode t) (setq fill-column 80))    @>


@q Local Variables: @>
@q mode:CWEB @>
@q eval:(display-time) @>
@q eval:(read-abbrev-file) @>
@q indent-tabs-mode:nil @>
@q eval:(outline-minor-mode) @>
@q End: @>
